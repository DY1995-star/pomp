---
title: "Frequently Asked Questions"
output:
  html_document:
    theme: default
    toc: yes
    number_sections: true
---

```{r options,include=FALSE}
require(knitr)
require(pomp)
knitr::opts_chunk$set(cache=FALSE,results="hide",echo=TRUE,fig.show="asis",
                      message=FALSE,warning=TRUE,error=TRUE)
```

# General.

## How can I submit an effective request for help?

Before submitting a request, examine the error messages and try to figure out what they are telling you by reading the help pages and/or the [package tutorials](http://kingaa.github.io/pomp/vignettes).
Check to see if you are using the latest version of **pomp**:
if not, check to see if the problem you have is solved by upgrading to the latest version.
Read through the [Frequently Asked Questions](FAQ) to see if the answer to your question is there.

If you still have a problem, then submit a request for help via the [Issues page](https://github.com/kingaa/pomp/issues) if possible or to Aaron King (kingaa at umich dot edu) if necessary.
Include in your request---at a minimum---the code that you ran that produced the error, together with a transcript of the **R** session that gave the errors.
Make sure to run `sessionInfo()` in your session, so that I can see what version of **pomp** you are using, what version of **R**, what kind of machine you have, etc.
Better still, construct a minimal example that will reproduce the error: this allows for the most efficient solution of problems.

## What's the proper way to cite **pomp**?

To cite the package, please be so kind as to follow the instructions given by executing 
```
citation("pomp")
```
in an **R** session.

If you use **pomp** in a publication, let us know!
Send an email with the citation, and we'll include it in [the bibliography](http://kingaa.github.io/pomp/biblio.html).

# Installation problems

## Why do I get an error message about `gfortran` when I try to install **pomp** from source on my Mac?

Compilation of **pomp** requires a FORTRAN compiler, which has not been installed (or not installed properly) on your system.
See the [installation instructions](http://kingaa.github.io/pomp/install.html#important-note-for-mac-os-x-users).

# Implementing POMP models.

## How can I include a vector of variables in a C snippet?

A C snippet can make use of any feature of the C language.
In particular, we can use pointers to give access to arrays.
For example, consider the following, which implement a simple chain of random variables.

```{r vector-vars-csnips}
rSim <- Csnippet("
  double *x = &X1;
  int i, n = (int) N;
  for (i = 0; i < n-1; i++) x[i] = x[i+1];
  x[n-1] = rnorm(0,1);
")
       
rInit <- Csnippet("
  double *x = &X1;
  int i, n = (int) N;
  for (i=0; i < n; i++) x[i] = 0.0;
")
```

The following simulates and plots using the above.

```{r vector-vars-pomp}
require(magrittr)
require(reshape2)
require(ggplot2)
        
data.frame(Y1=NA,t=1:20) %>% 
  pomp(times="t",t0=0,
       rprocess=euler.sim(rSim,delta.t=1),
       initializer=rInit,
       statenames=sprintf("X%d",1:5),
       paramnames="N",params=c(N=5),
       measurement.model=Y1~norm(-X1,2)
  ) %>%
  simulate(as.data.frame=TRUE) %>%
  melt(id=c('time','sim')) %>%
  ggplot(aes(x=time,y=value,group=variable,color=variable))+
  geom_line()+theme_bw()
```

## Can I write a `pomp` for multivariate data?

Yes, this is no problem.
The `data` you supply to `pomp` can contain multiple variables.
You simply refer to these variables by name in writing the `rmeasure` and `dmeasure` C snippets.
The following example illustrates this for a multivariate Ornstein-Uhlenbeck process (as in `pompExample("ou2")`) with a slightly peculiar measurement model.
```{r multivariate-data-pomp}
require(magrittr)
data.frame(t=1:100,y1=NA,y2=NA) %>%
  pomp(
    times="t", t0=0,
    rmeasure=Csnippet("
        y1 = rnorm(x1+x2,sigma1);
        y2 = rnorm(x2-x1,sigma2);
        "),
    dmeasure=Csnippet("
        lik = dnorm(y1,x1+x2,sigma1,1)+dnorm(y2,x2-x1,sigma2,1);
        lik = (log) ? lik : exp(lik);
        "),
    rprocess=discrete.time.sim(
      step.fun=Csnippet("
        double tx1, tx2;
        tx1 = rnorm(a11*x1 + a12*x2,nu1);
        tx2 = rnorm(a21*x1 + a22*x2,nu2);
        x1 = tx1; x2 = tx2;
      "),
      delta.t=1),
    initializer=Csnippet("
        x1 = 0;
        x2 = 0;
        "),
    statenames=c("x1","x2"),
    paramnames=c("a11","a12","a21","a22","sigma1","sigma2","nu1","nu2"),
    params=c(a11=0.5,a12=-0.1,a21=0.2,a22=-1,nu1=0.3,nu2=0.1,sigma1=0.1,sigma2=0.3)
  ) %>%
  simulate() -> obj
```

```{r multivariate-data-check,include=FALSE}
obj %>% pfilter(Np=1000) %>% logLik()
```

## How do I deal with missing data?

Missing data are a common complication.
**pomp** can handle NAs in the data, but the measurement model probability density function, `dmeasure`, if it is needed, must be written so as to deal with NAs appropriately.
For example, look at the following variant of [the SIR model describing the influenza outbreak in a boarding school](http://kingaa.github.io/sbied/stochsim/stochsim.html):

```{r}
library(pomp)
library(magrittr)
library(ggplot2)

read.csv(text="
B,day
NA,0
1,1
6,2
26,3
73,4
NA,5
293,6
258,7
236,8
191,9
124,10
69,11
26,12
11,13
4,14
") -> dat

dat %>%
  na.omit() %>%
  ggplot(aes(x=day, y=B)) +
  geom_line() + geom_point()
```

Data are missing at days 0 and 5.

We create a `pomp` object implementing a simple SIR process model and a binomial measurement model, as in the [original example](http://kingaa.github.io/short-course/stochsim/stochsim.html#the-boarding-school-flu-outbreak) (see also `pompExample(bsflu)`).
The only difference is in the `dmeasure`:

```{r}
sir_step <- Csnippet("
  double dN_SI = rbinom(S,1-exp(-Beta*I/N*dt));
  double dN_IR = rbinom(I,1-exp(-gamma*dt));
  S -= dN_SI;
  I += dN_SI - dN_IR;
  R += dN_IR;
  H += dN_IR;
")

sir_init <- Csnippet("
  S = N-1;
  I = 1;
  R = 0;
  H = 0;
")

rmeas <- Csnippet("B = rbinom(H,rho);")

dmeas <- Csnippet("if (ISNA(B)) {
                    lik = (give_log) ? 0 : 1;
                  } else {
                    lik = dbinom(B,H,rho,give_log);
                  }")

dat %>%
  pomp(time="day",t0=0,
       rprocess=euler.sim(sir_step,delta.t=1/12),
       initializer=sir_init,
       rmeasure=rmeas,
       dmeasure=dmeas,
       zeronames="H",
       paramnames=c("Beta","gamma","N", "rho"),
       statenames=c("S","I","R","H")
       ) -> sir_na
```

Note that the `dmeasure` returns a likelihood of 1 (log likelihood 0) for the missing data.
[What's the probability of seeing something if you don't look?]
When there is an observation, it returns a binomial likelihood as usual.

Our simulations now include simulations of the missing data,
```{r}
sir_na %>%
  simulate(params=c(Beta=3,gamma=2,rho=0.9,N=2600),
           nsim=10,as.data.frame=TRUE,include.data=TRUE) %>%
  ggplot(aes(x=time,y=B,group=sim,color=sim=="data"))+
  geom_line()+
  guides(color=FALSE)+
  theme_bw()
```

and the particle filter handles the missing data correctly:

```{r}
library(reshape2)

sir_na %>%
  pfilter(Np=1000,params=c(Beta=3,gamma=2,rho=0.9,N=2600)) %>%
  as.data.frame() %>%
  subset(select=-cond.loglik) %>%
  melt(id="time") %>%
  ggplot(aes(x=time,y=value,color=variable))+
  guides(color=FALSE)+
  geom_line()+
  facet_wrap(~variable,ncol=1,scales='free_y')+
  theme_bw()
```

In the above particle filter computation, notice that the effective sample size (ess) is full, as it should be, when the missing data contribute no information.

## I have t0 much less than t[1].  How do I deal with accumulator variables in this case?

As described in the documentation (`?pomp`), **pomp** allows you to define "accumulator variables" that collect events occurring between observations.
The example [above](#how-do-i-deal-with-missing-data) illustrates this.

In that example, we took `t0` equal to the first observation time.
Sometimes we want to take `t0` to be much earlier.
For example, if we wish to posit that the initial state of the unobserved Markov process is distributed at `t0` according to its stationary distribution, one way to achieve this is to put `t0` so early that simulations will equilibrate before the first observation is made.

This is straightforward, but the presence of accumulator variables leads to a small twist.
Let's look at the boarding-school flu example to illustrate.
```{r}
library(pomp)
library(magrittr)

sir_step <- Csnippet("
  double dN_SI = rbinom(S,1-exp(-Beta*I/N*dt));
  double dN_IR = rbinom(I,1-exp(-gamma*dt));
  S -= dN_SI;
  I += dN_SI - dN_IR;
  R += dN_IR;
  H += dN_IR;
  ")

sir_init <- Csnippet("
  S = N-1;
  I = 1;
  R = 0;
  H = 0;
")

rmeas <- Csnippet("B = rbinom(H,rho);")

dmeas <- Csnippet("if (ISNA(B)) {
                  lik = (give_log) ? 0 : 1;
} else {
                  lik = dbinom(B,H,rho,give_log);
}")

read.csv(text="
day,B
1,3
2,8
3,28
4,76
5,222
6,293
7,257
8,237
9,192
10,126
11,70
12,28
13,12
14,5
") -> dat

dat %>%
  pomp(time="day",t0=-8,
       rprocess=euler.sim(sir_step,delta.t=1/12),
       initializer=sir_init,
       rmeasure=rmeas,
       dmeasure=dmeas,
       zeronames="H",
       paramnames=c("Beta","gamma","N", "rho"),
       statenames=c("S","I","R","H")
       ) -> bsflu
```

Note that, as [above](#how-do-i-deal-with-missing-data), we've allowed for the possibility of NAs in the data.

Now let's look at the data and some simulations from the model.

```{r}
library(ggplot2)

bsflu %>%
  as.data.frame() %>%
  ggplot(aes(x=time,y=B))+
  geom_point()+geom_line()+
  theme_bw()

bsflu %>%
  simulate(params=c(Beta=1.5,gamma=1,rho=0.9,N=2600),
           nsim=10,as.data.frame=TRUE,include.data=TRUE) %>%
  ggplot(aes(x=time,y=B,group=sim,color=sim=="data"))+
  geom_line()+
  guides(color=FALSE)+
  theme_bw()
```

The data plot looks fine, but what's going on with the simulations?
It's easy to understand: we are assuming that there is one infectious host at `t = t0 = -8` days.
In most of the simulations, this leads to a number of new infections, which the `H` variable accumulates from `t=-8` to `t=1`, the time of our first observation.
But our first observation is not the number of new cases to have occurred in the last 9 days, but the number that occurred (and were reported) in the last 1 day.

We can fix this by introducing a fictitious "observation" at `t=0`, with missing data, i.e., by assuming we observed nothing at `t=0`:

```{r}
library(plyr)

dat %>%
  rbind(data.frame(day=0,B=NA)) %>%
  arrange(day) %>%
  pomp(time="day",t0=-8,
       rprocess=euler.sim(sir_step,delta.t=1/12),
       initializer=sir_init,
       rmeasure=rmeas,
       dmeasure=dmeas,
       zeronames="H",
       paramnames=c("Beta","gamma","N", "rho"),
       statenames=c("S","I","R","H")
  ) -> bsflu

bsflu %>%
  simulate(params=c(Beta=1.5,gamma=1,rho=0.9,N=2600),
           nsim=10,as.data.frame=TRUE,include.data=TRUE) %>%
  subset(time>=1) %>%
  ggplot(aes(x=time,y=B,group=sim,color=sim=="data"))+
  geom_line()+
  guides(color=FALSE)+
  theme_bw()
```


# Error messages.

## I see an error about `dmeasure` returning non-finite values.  What does it mean?

A common error message is 
```
Error : in ‘pfilter’: ‘dmeasure’ returns non-finite value
```

This error arises because your `dmeasure` function is giving a non-finite value of the likelihood.
Common causes are:

- negative or non-integer state variables when the dmeasure assumes non-negative or integer values,
- missing data,
- the `dmeasure` function or C snippet returning the log likelihood when the likelihood is requested, or vice versa.

See the help (`?Csnippet`) for information on how to properly write `dmeasure` C snippets.
As of version 1.5.6.3, when this error occurs, the values of the likelihood, parameters, and states are printed.
If this alone doesn't make the underlying cause clear, explore the model behavior further.
A useful way to do this is to put [`Rprintf` statements](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Printing) in your `dmeasure` and `rprocess` C snippets to view the values of the data, state variables, and likelihoods.
[Issue #13](https://github.com/kingaa/pomp/issues/13) has an example.

Remember, `dmeasure` has to be able to return the likelihood---or the log likelihood---upon request!

## Why can't I run the demos, or other codes that use the C snippet facility?

<a id="csnippet-problems"></a>

If your system does not support `R CMD SHLIB`, you won't be able to use C snippets.
**R** compiles native codes (C and FORTRAN) into shared-object libraries using `SHLIB`.
To check whether your **R** installation is configured to use `SHLIB`, run the following code snippet in an **R** session:
```
cat("#include <R.h>
void hello (void) {
  Rprintf(\"hello world!\\n\");
}",file="hello.c")
system("R CMD SHLIB hello.c")
dyn.load(paste0("hello",.Platform$dynlib.ext))
.C("hello",PACKAGE="hello")
```
If it works, you should see
```
hello world!
list()
```
If it doesn't work, consult the [installation instructions](http://kingaa.github.io/pomp/install.html).


## Why do I get an error message "Could not compile shared-object library" when I run `pomp`?

See [the preceding FAQ](#csnippet-problems).

# Interpreting results

## Is the likelihood `mif` gives me the same as the likelihood I get from `pfilter`?

No.  As its name suggests, iterated filtering (IF) algorithms (those implemented in **pomp** as `mif` and `mif2`) work by iteratively performing particle filtering on a model, but that model is slightly different from the focal model.
In particular, IF pertubs the parameters of the model by adding random noise to them.
Actually, if one were to simulate from this model, the parameters would be taking random walks.
This effectively smooths the likelihood surface, combats particle depletion, and---critically for IF---allows local exploration of the parameter space.
The likelihood that `mif` and `mif2` report is the estimated likelihood of this perturbed model.
It can be either higher or lower than that of the focal model.
Iterated filtering works by gradually reducing the magnitude of the perturbations with successive iterations ("cooling"), so that the perturbed model gradually becomes more similar to the focal model.

To compute the likelihood at a point returned by `mif` or `mif2`, it is necessary to re-run the particle filter.
By doing the latter several times, one can obtain a more accurate estimate of the likelihood along with a measure of the associated uncertainty.
